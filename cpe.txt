#include <cctype>
toupper(c);
c = tolower(c);

qsort(alphabet, 26, sizeof(struct data), compare);

/* 
   若 a 的 priority 較大 -> return 1 (a 放右邊)
   若 a 的 priority 較小 -> return 0 (a 放左邊)
   qsort 的排序是由 priority 小 排到 priority 大 
*/
int compare(const void *a, const void *b)
{
    int data_a = *(int *)a;
    int data_b = *(int *)b;
    if(data_a < data_b) return 0;              
    else return 1;          
    /* output a b */        
}

while(cin.get(c)) 

char keyboard[] = "qwertyuiop[]" "asdfghjkl;'" "zxcvbnm,.";

#include <cstring>
char *ret;
ret = strchr(keyboard, c);
找不到會回傳NULL

cin >> c 不能接到空白 換行 tab 之類的
所以要用 cin.get(c)

#include <string>
string str;
str.length() 不含空白字元

int -> string
str = to_string(sum);

#include <string>
getline(cin, str1) 可以接收空格 cin >> str 不能接收空格
str1 是不含換行符號的

char a[100][101];
while(cin.getline(a[row], 101)) a[row] 是 char array

getline(cin, str) str 是一個 string
cin.getline(a[row], 101) 

string weekDay[7] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};

set<int> jolly;
jolly.insert(abs(arr[i] - arr[i-1]));
jolly.size()
jolly.clear();

#include <iomanip>
cout << fixed << setprecision(4) << pb << endl;

#include <math.h>
pow(1-P, I-1)

double d = 1000000000;
cout << d << endl; -> 1e+09
cout << (long long)d << endl; -> 1000000000
用double的話會變成科學符號表示法

while(cin >> x) {

    getchar();
    getline(cin, s);
}

#include <sstream>
#include <string>

string s, str;
stringstream ss;

ss << s; // 把s放進stringstream
while(ss >> str) { // ss會像是cin的把ss裡的東西輸出進str
    n = stoi(str); // stoi string->int
    a.push_back(n);
}

ss.clear(); // 清空stringstream

vector<long long> a; // 題目說係數會是int範圍 但作微分之後係數會變大 所以要用long long
long long xPoly;
long long sum;

a.push_back(n); // 從後面push進去
a.pop_back(); // 從後面丟掉一個
size = a.size(); 
a.clear();

for(int i = 0; i < N; i++) {
    for(int j = 0; j < N; j++) {
        cin >> M[i][j];
        if(M[i][j] < 0) flag = 1; 
        // 不能直接break 不然會影響輸入
    }
}


retInt = strBase.find(strR[i]);
如果沒有找到 回傳-1

rsd如果不這樣邊mod邊做
rsd會超過int範圍
rsd = 0
for(int i = 0; i < len; i++) {
    rsd = rsd * base +  strR[i];
    rsd = rsd % (base - 1);
}
rsd是餘數 (int)strR % (base - 1)

以下是算出一個以strR表示的int(以base為底)
rsd = 0
for(int i = 0; i < len; i++) {
    rsd = rsd * base +  strR[i];
}
rsd是 (int)strR